# 6.2 内存安全问题在 OceanBase 的解决方案

C++ 程序世界里开发者可以直接操控内存，享受极致性能的同时也催生了无穷无尽的内存安全漏洞，每个漏洞都有可能让服务器崩溃并且需要测试开发人员投入大量的排查精力。功能不断迭代的背景下漏洞是很难避免的，如何快速发现这些漏洞并精准定位，是个很大的议题。

最常用方法有 mprotect 和 Address Sanity（Asan)。mprotect 方案有很大的限制，一方面它要求地址是 OS page 对齐的，另一方面长度也必须是 page size 的整数倍，这样就无法保护小字节内存。而 Asan 方案就比较通用了，它可以说是核武器级别的，Asan 依靠编译插桩技术实现的运行期检查可以发现各种各样的安全漏洞，哪怕很小的内存越界都可以检查到。

OceanBase 也依靠 Asan 发现了很多关键 bug。但随着压测环境的逐渐丰富与壮大，Asan 逐渐不适用，原因就是它的性能表现不佳。高并发服务器程序对测试压力的要求也很高，Asan 不能很好地保证性能测试质量。

Asan 性能不佳的主要原因：

- Malloc 多核性能太差，有单点瓶颈

- 支持栈内存与全局变量的检查，overhead 高

- 为了极致的易用性，malloc/free 堆栈全纪录，backtrace 性能差

基于以上原因，OceanBase 自研了一套 Sanity 框架，设计思路与 Asan 比较相似，但因为 Malloc 是自己实现的，所以多核性能扩展性较好，不会再有单点瓶颈问题。

接下来介绍一下 Sanity 框架是怎么实现的。首先它也是依靠编译技术实现，即编译阶段修改 OBServer 的代码，在所有访存指令之前插入检查函数。这个函数会检查目标地址是否可以访问，不可以访问则直接 abort，让程序崩溃，这样就可以把第一现场保留下来。

为了快速判定地址是否可访问，OceanBase 定义了 shadow 内存，所有分配的内存都会有相应的元信息内存，这个元信息记录了源内存是否可访问。为了高效，元信息地址与跟原始内存地址是 8 倍关系，即原始地址右移三位就是元信息地址，这么设计的好处是可以快速索引。另外它们的地址是隔离的，所以不存在用户数据写坏元信息的问题，既满足了高效要求，也满足了隔离性需求。

编码规则也比较简单，用 1 字节的内存来表示 8 字节的用户数据。0x0 代表相应 8 字节全部可访问；0xf0 代表相应 8 字节全部不可访问；0x${n} 表示 8 字节里前 n 个字节可访问，后 8-n 个字节不可访问。

另外 Sanity 框架有一些优化，一个是通过设置隔离区延迟内存的复用，大幅提高 use-after-free 漏洞的检查概率。另一个是记录调用链，调用链对于排查 use-after-free 问题很有用。
