# 6.1 内存管理框架

本节主要通过性能、利用率和诊断性三个方面来介绍 OceanBase 内存管理框架。

## 性能

OceanBase 的内存管理框架是一个多路的设计，可以充分利用多核性能。前台线程会有一些无锁的线程局部设计，可以让前台请求的 RT 变得更小。针对一些特定场景，还有专用的分配器，可以进一步榨干系统的性能。

如下图所示，内存管理整体上就是一个多租户的框架。租户往下再进一步细分为不同的 context（起隔离作用），不同 context 的内存地址是不同的，即不同 context 之间不会相互干扰，比如不存在 context1 的逻辑写坏 context2 这种情况。每个 context 下面会有多个 object_pool, 每一次内存申请都可以通过线程号散列到一个特定的 object_pool, 这样就可以把多核的性能充分利用起来。

![01](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/kernel-advanced/V1.0.0/zh-CN/6.memory-frame/2.ob-memry-frame-01.png)

针对前台请求线程可以去做一些优化，即存在一些线程局部的缓存设计。每个工作线程上保留 2M ~ 4M 大小的缓存，专用于 SQL 处理过程中的临时内存需求。这样设计的好处如下：

- 高效

  - 在整个 SQL 执行过程中不会再跟其他线程有临界区冲突。

  - 整个链路上是无锁的，所以可以避免并发控制相关数据结构的 overhead。

- 零碎片

  SQL 处理过程通常要连续申请大量的小内存块，由于总是优先从线程上申请，这些内存块与其他模块的长生命周期内存完全隔离，因此避免了可能的碎片问题。

- 零内存泄漏

  由于专用于处理 SQL 请求，SQL 结束后可完全回收内存，即使代码存在泄露 BUG 也能兜底。

除此之外，针对一些特定场景，通用分配器性能或空间占用依然不满足的情况，内核还设计了多种专用分配器，有的是为了性能，有的是为了空间利用率。

- 用于短生命周期的高效分配器，适用多次分配一次释放的场景，可以更好地提高性能。

- 用于先申请先释放特征的分配器，可达到极致的空间利用率。

- 统一对象池，节省初始化开销，充分榨干性能。

## 利用率

关于利用率，OceanBase 有一个比较通用的 KVCache 框架。具备 KV 使用模式特点的模块，比如 schema 对象、热点 row 等，都使用 KVCache 框架来管理。KVCache 除了高效以外最重要的特点就是可挤占，也就是说当内存充足的时候可以充分利用内存提高性能，如果内存不充足也可以从这个框架里挤占，避免报错。另外 KVCache 还具备碎片整理的功能，这个功能对 schema 对象的管理是非常重要的，因为 schema 对象的生命周期是随机的，碎片整理可以有效解决长期随机 DDL 造成的碎片化问题。

另外 OceanBase 还有一个碎片自动淘汰机制。大型服务器程序常态运行的内存碎片其实是难以避免的，碎片会降低空间利用率，严重可能会拖垮系统。这其实是不同生命周期的顶层模块之间共享内存造成的，常规的修复思路是靠顶层模块解决，但对于 OceanBase 这样追求极致稳定性的系统来说选择底层优化是必然的选择。

OceanBase 内核认为碎片是一定会存在的，只要能在合适的时间对碎片进行清理就可以。做法也很简单，直接利用 madive 系统调用的 MADV_DONTNEED 选项，它能够在保留虚拟地址的前提下释放物理内存。那为什么不直接用 munmap 呢？因为 munmap 会增加系统 vma 的数量，一个 vma 代表一片连续、具有相同属性的虚拟地址空间，vma 数量多会影响系统调用的性能。但是用 madvise，就可以把碎片清除的同时保证不影响性能。

## 诊断

首先思考一个问题，系统的内存都去哪里了呢？OceanBase 是怎么做的？

在 OceanBase 中强制要求调用 ob_malloc 函数的代码都必须传入内存归属信息，包括租户 ID、模块 ID 等，这样所有内存块都能唯一对应一个归属信息，所有这些信息统一汇总到日志与虚拟表中，如下图所示，最后一列是各个模块，这样就可以清晰的知道系统的内存都去了哪里。

![02](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/kernel-advanced/V1.0.0/zh-CN/6.memory-frame/2.ob-memry-frame-02.png)

另外就是内存泄漏问题。针对泄漏诊断，OceanBase 提供了事前与事后两种机制。事前机制是当泄漏持续发生时可以通过 SQL 命令开启对某个模块的跟踪，这样就可以从虚拟表里实时看到哪些代码发生了泄漏（实际上函数调用链）。

但事前机制解决不了泄露已经停止的场景，所以还需要有一个事后机制，常态运行时会有一个针对 ob_malloc 的采样功能，即使是内存泄漏不再出现，也可以通过历史采样信息追溯内存都去了哪里。虽然是采样，但如果泄露的次数足够多或者泄露的大小足够大，也足以用来定位问题。这两个机制可以帮助 OceanBase 解决大部分的内存泄漏问题。
