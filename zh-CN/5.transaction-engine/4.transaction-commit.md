# 5.3 事务提交

## 流程

传统的事务两阶段提交，协调者也会写日志持久化状态，先进行 prepare 阶段，再进行 commit 阶段，当参与者全部返回 commit ok 之后，再给用户返回提交成功。

OceanBase 在此基础上进行了优化：

1. 协调者不再保存事务提交状态，减少日志开销；

2. 不用等到 commit log 写入就返回给用户，减少了等待日志写入的时间；

3. 增加了 pre commit 阶段，是为了刷新参与者的最大提交版本号，避免出现外部一致性问题；

4. 增加了 clear 阶段，保留事务的 commit 状态。

具体流程如下图：

![流程](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/kernel-advanced/V1.0.0/zh-CN/5.transaction-engine/4.transaction-commit-01.png)

其中：

* prepare：生成 prepare version;

* pre commit：推高本地 max commit version;

* Commit/Abort：日志多数派成功之后，解行锁，应答客户端；

* Clear：释放参与者上下文；

## 思考1：为什么要有 pre commit 阶段？

产生原因：

性能优化的需求，单分区本地查询请求，取 max_commit_version 作为读快照，减少获取 GTS 开销。

解决方案：

1. 每条 SQL 均从 GTS 获取语句快照（影响性能）；

2. Pre commit 方案，统一刷新所有参与者的最大提交版本号，全部刷新后再告诉用户提交成功，之后用户在多分区查询时读到的数据都是新的。

## 思考 2：为什么要有 clear 阶段？

OB 2PC 之所以需要加一个 CLEAR 阶段，是基于工程实现上的考虑。

如果没有 clear 阶段，考虑下面的场景如何处理：

某分布式事务涉及两个参与者 P1、P2，事务提交过程中，整体发生过宕机重启。重启完成之后，其中 P1 的内存状态已经结束，P2 处于 Prepare 阶段，后续该事务 2PC 推进过程中，事务提交结果是 Commit 成功还是失败？

查磁盘日志当然可以知道，但是遍历日志的代价未免太大。

有了 clear  阶段，事务 commit 之后 context 仍然存在，协调者宕机重启之后就能看到参与者的 prepare 状态和 commit 状态。
